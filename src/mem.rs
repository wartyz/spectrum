//use crossterm::*;

use crossterm::Result;
use crate::procesador::PROCESADOR;


//static u8 BootROM[] = {

//};


#[derive(Copy, Clone)]
pub struct MEM {
    procesador: PROCESADOR,
    ram: [u8; 65_536],
    ports: [u8; 256],
    rom_gb: [u8; 256],
    rom_cerrada: bool,
}


impl MEM {
    pub fn new(procesador: PROCESADOR) -> MEM {
        let mem = MEM {
            procesador: procesador,
            ram: [0; 65_536], //0x0000 to 0xFFFF
            ports: [0; 256],  //0x00 to 0xFF
            rom_gb: [         // ROM de GameBoy
                0x31, 0xfe, 0xff, 0xaf, 0x21, 0xff, 0x9f, 0x32, 0xcb, 0x7c, 0x20, 0xfb, 0x21, 0x26, 0xff, 0x0e,
                0x11, 0x3e, 0x80, 0x32, 0xe2, 0x0c, 0x3e, 0xf3, 0xe2, 0x32, 0x3e, 0x77, 0x77, 0x3e, 0xfc, 0xe0,
                0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1a, 0xcd, 0x95, 0x00, 0xcd, 0x96, 0x00, 0x13, 0x7b,
                0xfe, 0x34, 0x20, 0xf3, 0x11, 0xd8, 0x00, 0x06, 0x08, 0x1a, 0x13, 0x22, 0x23, 0x05, 0x20, 0xf9,
                0x3e, 0x19, 0xea, 0x10, 0x99, 0x21, 0x2f, 0x99, 0x0e, 0x0c, 0x3d, 0x28, 0x08, 0x32, 0x0d, 0x20,
                0xf9, 0x2e, 0x0f, 0x18, 0xf3, 0x67, 0x3e, 0x64, 0x57, 0xe0, 0x42, 0x3e, 0x91, 0xe0, 0x40, 0x04,
                0x1e, 0x02, 0x0e, 0x0c, 0xf0, 0x44, 0xfe, 0x90, 0x20, 0xfa, 0x0d, 0x20, 0xf7, 0x1d, 0x20, 0xf2,
                0x0e, 0x13, 0x24, 0x7c, 0x1e, 0x83, 0xfe, 0x62, 0x28, 0x06, 0x1e, 0xc1, 0xfe, 0x64, 0x20, 0x06,
                0x7b, 0xe2, 0x0c, 0x3e, 0x87, 0xe2, 0xf0, 0x42, 0x90, 0xe0, 0x42, 0x15, 0x20, 0xd2, 0x05, 0x20,
                0x4f, 0x16, 0x20, 0x18, 0xcb, 0x4f, 0x06, 0x04, 0xc5, 0xcb, 0x11, 0x17, 0xc1, 0xcb, 0x11, 0x17,
                0x05, 0x20, 0xf5, 0x22, 0x23, 0x22, 0x23, 0xc9, 0xce, 0xed, 0x66, 0x66, 0xcc, 0x0d, 0x00, 0x0b,
                0x03, 0x73, 0x00, 0x83, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x08, 0x11, 0x1f, 0x88, 0x89, 0x00, 0x0e,
                0xdc, 0xcc, 0x6e, 0xe6, 0xdd, 0xdd, 0xd9, 0x99, 0xbb, 0xbb, 0x67, 0x63, 0x6e, 0x0e, 0xec, 0xcc,
                0xdd, 0xdc, 0x99, 0x9f, 0xbb, 0xb9, 0x33, 0x3e, 0x3c, 0x42, 0xb9, 0xa5, 0xb9, 0xa5, 0x42, 0x3c,
                0x21, 0x04, 0x01, 0x11, 0xa8, 0x00, 0x1a, 0x13, 0xbe, 0x20, 0xfe, 0x23, 0x7d, 0xfe, 0x34, 0x20,
                0xf5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xfb, 0x86, 0x20, 0xfe, 0x3e, 0x01, 0xe0, 0x50,
            ],
            rom_cerrada: false,
        };
        mem
    }

    pub fn cierra_rom(&mut self) {
        self.rom_cerrada = true;
    }

    pub fn escribe_byte_en_mem(&mut self, address: u16, value: u8) {
//        if address < 0x4000 && self.rom_cerrada {
//            panic!("Intento de escribir en ROM");
//        }


        self.ram[address as usize] = value;
    }

    pub fn lee_byte_de_mem(&self, address: u16) -> u8 {
        match self.procesador {
            PROCESADOR::SharpLr35902 => {
                //println!("address={:#04X}", address);
                if (address <= 0x00FF) && (self.ram[0xFF50] != 1) {
                    self.rom_gb[address as usize]
                } else {
                    self.ram[address as usize]
                }
            }

            PROCESADOR::Z80 => { self.ram[address as usize] }
            _ => { 0 }
        }

//        if (self.procesador == PROCESADOR::SharpLr35902) && (address < 0x00FF) && self.ram[0xFF50] == 0 {
//            self.romGB[address as usize]
//        } else {
//            self.ram[address as usize]
//        }
    }

    pub fn escribe_2bytes_en_mem(&mut self, address: u16, value: u16) {
        let lo = (0x00FF & value) as u8;
        self.escribe_byte_en_mem(address, lo);
        let hi = (0xFF00 & value) as u8;
        self.escribe_byte_en_mem(address + 1, hi)
    }

    pub fn lee_2bytes_de_mem(&self, address: u16) -> u16 {
        let lo = self.lee_byte_de_mem(address);
        let hi = self.lee_byte_de_mem(address + 1);
        ((hi as u16) << 8) | lo as u16
    }

    pub fn escribe_byte_en_port(&mut self, address: u8, value: u8) {
        self.ports[address as usize] = value;
    }

    pub fn lee_byte_de_port(&self, address: u8) -> u8 {
        self.ports[address as usize]
    }


    pub fn rellena_mem_desde_fichero_rom(&mut self, rom_file: &[u8]) {
        //let bytes = &rom_file[..rom_file.len()];
        let mut i: u16 = 0x0000;
        for &byte in rom_file.iter() {
            //println!("{:#x}", (byte as u16));
            self.escribe_byte_en_mem(i, byte);
            i += 1;
        }
    }
}